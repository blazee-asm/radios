<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Awesome radio app where you can listen to multiple channels." charset="UTF-8">
  <title>Radio</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap');

    #notes {
        font-family: 'Patrick Hand', cursive;
        background: #fff8dc;
        padding: 1rem;
        border: 1px solid #ccc;
        border-radius: 6px;
        box-shadow: 1px 1px 5px rgba(0,0,0,0.1);
        max-width: 300px;
        white-space: pre-wrap;
    }

    body { font-family: sans-serif; padding: 1rem; }
  </style>
</head>
<body>
    <h1>Radio</h1>
    <input placeholder="Channel here..." id="channelIn" /><button onclick="setChannel()">Enter</button><br>
    <p id="data"></p><br><br><br>
    <textarea id="notes" rows="5" cols="40" placeholder="Write your notes here..."></textarea><br>
    <button id="saveNotes">Save</button>
    <button id="loadNotes">Load</button>

    <script>
        const display = document.getElementById('data');
        const channelInput = document.getElementById('channelIn');
        const notesArea = document.getElementById('notes');

        function setChannel() {
            channel = channelInput.value;
        }

        function createGibberish(len) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
            let result = '';
            for (let i = 0; i < len; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function saveNotes() {
            const notes = notesArea.value.split('\n');
            localStorage.setItem("savedChannels", notes);
        }

        async function getLocation() {
            try {
                const res = await fetch('https://ipinfo.io/json?token='); // You can add your token here for better limits or leave empty
                if (!res.ok) throw new Error('Failed to fetch IP location');
                const data = await res.json();
                if (!data.loc) throw new Error('No location data');
                const [lat, lon] = data.loc.split(',').map(Number);
                return { lat, lon };
            } catch (err) {
                console.error('Failed to get location:', err.message);
                return null;
            }
        }

        async function getWeather() {
            function describeWeatherCode(code) {
                const codeInt = Math.round(code);
                switch (codeInt) {
                    case 0: return 'Clear skies, go outside!';
                    case 1: return 'Mainly clear, why not go shopping?';
                    case 2: return 'Partly cloudy, we recommend to maybe stay inside.';
                    case 3: return 'Fully clouded, stay inside!';
                    case 45: return 'Fog, eerie...';
                    case 48: return 'Icy fog, eerie...';
                    case 51: return 'Light drizzle, stay inside to not get wet!';
                    case 53: return 'Moderate drizzle, you might feel it on your head.';
                    case 55: return 'Dense drizzle, might be loud.';
                    case 56: return 'Light freezing drizzle, icy!';
                    case 57: return 'Dense freezing drizzle, icy!';
                    case 61: return 'Slight rain, it\'s rainy.';
                    case 63: return 'Moderate rain, yikes!';
                    case 65: return 'Heavy rain, is it summer?';
                    case 66: return 'Light freezing rain, this is gonna be very icy.';
                    case 67: return 'Heavy freezing rain, this is gonna be very icy.';
                    case 71: return 'Slight snow fall, snow angels?';
                    case 73: return 'Moderate snow fall, snowball fights!';
                    case 75: return 'Heavy snow fall, stay inside then get ready for snowmen!';
                    case 77: return 'Snow grains';
                    case 80: return 'Slight rain showers';
                    case 81: return 'Moderate rain showers';
                    case 82: return 'Torrential rain, happens in summer during big climate changes.';
                    case 85: return 'Slight snow showers, melting on impact? Dunno.';
                    case 86: return 'Heavy snow showers, ice-cold baths!';
                    case 95: return 'Thunderstorm, loud!';
                    case 96: return 'Thunderstorm with slight hail, double whammy!';
                    case 99: return 'Thunderstorm with heavy hail, I don\'t know what to say...';
                    default: return 'Unknown weather, we just... don\'t know.';
                }
            }

            try {
                const locData = await getLocation();
                if (!locData) throw new Error('IP location fetch failed');
                const { lat, lon } = locData;

                const weatherRes = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`);
                if (!weatherRes.ok) throw new Error('Failed to fetch weather');
                const weatherData = await weatherRes.json();

                if (!weatherData.current_weather) return 'Can\'t fetch weather. :(';

                return "Weather: " + describeWeatherCode(weatherData.current_weather.weathercode);

            } catch (err) {
                console.error(err);
                return null;
            }
        }

        async function showWeather() {
            const weatherText = await getWeather();
            display.innerHTML = weatherText || "Can't get weather :(";
        }

        function replaceImageLinks(str) {
            return str.replace(
                /_image=(https?:\/\/[^\s]+\.(?:png|jpe?g|webp|gif|bmp|svg))_/gi,
                '<img src="$1" />'
            );
        }

        async function replaceAudioLinks(str) {
            let match = str.match(/_audio=(https?:\/\/[^\s]+\.(?:mp3|wav|ogg|m4a|aac))_/i);
            if (match) delay = await getAudioDuration(match[0].slice(7, -1));
            return str.replace(
                /_audio=(https?:\/\/[^\s]+\.(?:mp3|wav|ogg|m4a|aac))_/gi,
                (_, url) => `<audio src="${url}" autoplay loop></audio>`
            );
        }

        async function parseStr(input) {
            let output = replaceImageLinks(input);
            output = await replaceAudioLinks(output);
            return output;
        }

        async function getAudioDuration(url) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.crossOrigin = 'anonymous';
                audio.src = url;
                audio.addEventListener('loadedmetadata', () => {
                    resolve(audio.duration * 1000);
                });
                audio.addEventListener('error', (e) => {
                    reject(e);
                });
            });
        }

        let data = null;
        let channel = "1000";
        let prevChannel = null;
        let delay = 3000;
        let pendingFetch = false;

        async function fetchChannelData(chan) {
            if (pendingFetch) return; // prevent multiple simultaneous fetches
            pendingFetch = true;
            try {
                const res = await fetch(`channel-${chan}.json`);
                if (!res.ok) throw new Error('Failed to fetch channel data');
                data = await res.json();
                prevChannel = chan;
            } catch (err) {
                data = null;
                console.error(err);
            } finally {
                pendingFetch = false;
            }
        }

        async function setChannel() {
            const newChannel = channelInput.value.trim();
            if (newChannel && newChannel !== channel) {
                channel = newChannel;
                await fetchChannelData(channel);
                updateDisplayOnce();
            }
        }

        async function updateDisplayOnce() {
            if (!Array.isArray(data)) {
                display.textContent = createGibberish(50);
            } else {
                const now = Date.now();
                const idx = Math.floor(now / delay);
                const currentStr = data[idx % data.length];
                switch (currentStr) {
                    case "__weather__":
                        await showWeather();
                        break;
                    default:
                        display.innerHTML = await parseStr(currentStr);
                }
            }
        }

        async function tick() {
            if (pendingFetch) {
                display.textContent = createGibberish(50);
                setTimeout(tick, 20); // very fast retry if fetching
                return;
            }

            // If channel changed but fetch didnâ€™t happen yet, fetch it (fallback)
            if (prevChannel !== channel) {
                await fetchChannelData(channel);
            }

            // Show current message
            await updateDisplayOnce();

            setTimeout(tick, delay);
        }

        tick();
    </script>
</body>
</html>