<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="description" content="Awesome radio app where you can listen to multiple channels." />
    <title>Radio</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Patrick+Hand&display=swap');

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5dc; /* soft cream */
            color: #333;
            margin: 0;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        h1 {
            font-family: 'Patrick Hand', cursive;
            font-size: 3rem;
            margin-bottom: 1rem;
            color: #2a2a72; /* dark blue */
            text-shadow: 1px 1px 2px #b0c4de;
        }

        #channelIn {
            font-family: 'Patrick Hand', cursive;
            width: 600px;
            padding: 0.5rem;
            font-size: 1.2rem;
            border: 2px solid #2a2a72;
            border-radius: 10px;
            margin-right: 1rem;
            transition: border-color 0.3s ease;
        }

        #channelIn:focus {
            outline: none;
            border-color: #ff8c00; /* accent orange */
        }

        button {
            font-family: 'Patrick Hand', cursive;
            background-color: #2a2a72;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 0.6rem 1.2rem;
            font-size: 1rem;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        button:hover {
            background-color: #ff8c00;
            transform: scale(1.05);
        }

        #data {
            font-family: 'Patrick Hand', cursive;
            background-color: #fff;
            border: 2px solid #2a2a72;
            border-radius: 15px;
            padding: 1.5rem;
            margin-top: 2rem;
            max-width: 600px;
            min-height: 100px;
            font-size: 1.25rem;
            line-height: 1.5;
            white-space: pre-wrap;
            box-shadow: 0 0 10px rgba(42, 42, 114, 0.3);
        }

        #notes {
            max-width: 600px;
            width: 100%;
            margin-top: 2rem;
            font-size: 1.1rem;
            line-height: 1.4;
            background-color: #fff8dc;
            border: 1px solid #ccc;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 1px 1px 5px rgba(0,0,0,0.1);
            white-space: pre-wrap;
        }

        @media (max-width: 600px) {
            button {
                width: 100%;
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <h1>Radio</h1>
    <label for="channelSelect">Choose a channel:</label>
    <select id="channelSelect">
        <option value="">Loading...</option>
    </select>
    <label for="channelIn">Channel: <span id="channelDisplay">1000</span></label><br>
    <input
        type="range"
        id="channelIn"
        min="0"
        max="4096"
        value="1000"
    />
    <button onclick="setChannel()">Enter</button><br>
    <p id="data"></p><br><br><br>
    <textarea id="notes" rows="5" cols="40" placeholder="Write your favorite channels here!"></textarea><br>
    <button id="saveNotes" onclick="saveNotes()">Save</button>
    <button id="loadNotes" onclick="loadNotes()">Load</button>

    <script>
        const display = document.getElementById('data');
        const channelInput = document.getElementById('channelIn');
        const notesArea = document.getElementById('notes');
        const channelDisp = document.getElementById('channelDisplay');

        // Update displayed number as slider moves
        channelInput.addEventListener('input', () => {
            channelDisp.textContent = channelInput.value;
        });

        function createGibberish(len) {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';
            let result = '';
            for (let i = 0; i < len; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function saveNotes() {
            const notes = notesArea.value;
            localStorage.setItem("savedChannels", notes);
        }

        function loadNotes() {
            const notes = localStorage.getItem("savedChannels");
            notesArea.value = notes || "";
        }

        async function getLocation() {
            try {
                const res = await fetch('https://ipinfo.io/json?token='); // You can add your token here for better limits or leave empty
                if (!res.ok) throw new Error('Failed to fetch IP location');
                const data = await res.json();
                if (!data.loc) throw new Error('No location data');
                const [lat, lon] = data.loc.split(',').map(Number);
                return { lat, lon };
            } catch (err) {
                console.error('Failed to get location:', err.message);
                return null;
            }
        }

        async function getWeather() {
            function describeWeatherCode(code) {
                const codeInt = Math.round(code);
                switch (codeInt) {
                    case 0: return 'Clear skies, go outside!';
                    case 1: return 'Mainly clear, why not go shopping?';
                    case 2: return 'Partly cloudy, we recommend to maybe stay inside.';
                    case 3: return 'Fully clouded, stay inside!';
                    case 45: return 'Fog, eerie...';
                    case 48: return 'Icy fog, eerie...';
                    case 51: return 'Light drizzle, stay inside to not get wet!';
                    case 53: return 'Moderate drizzle, you might feel it on your head.';
                    case 55: return 'Dense drizzle, might be loud.';
                    case 56: return 'Light freezing drizzle, icy!';
                    case 57: return 'Dense freezing drizzle, icy!';
                    case 61: return 'Slight rain, it\'s rainy.';
                    case 63: return 'Moderate rain, yikes!';
                    case 65: return 'Heavy rain, is it summer?';
                    case 66: return 'Light freezing rain, this is gonna be very icy.';
                    case 67: return 'Heavy freezing rain, this is gonna be very icy.';
                    case 71: return 'Slight snow fall, snow angels?';
                    case 73: return 'Moderate snow fall, snowball fights!';
                    case 75: return 'Heavy snow fall, stay inside then get ready for snowmen!';
                    case 77: return 'Snow grains';
                    case 80: return 'Slight rain showers';
                    case 81: return 'Moderate rain showers';
                    case 82: return 'Torrential rain, happens in summer during big climate changes.';
                    case 85: return 'Slight snow showers, melting on impact? Dunno.';
                    case 86: return 'Heavy snow showers, ice-cold baths!';
                    case 95: return 'Thunderstorm, loud!';
                    case 96: return 'Thunderstorm with slight hail, double whammy!';
                    case 99: return 'Thunderstorm with heavy hail, I don\'t know what to say...';
                    default: return 'Unknown weather, we just... don\'t know.';
                }
            }

            try {
                const locData = await getLocation();
                if (!locData) throw new Error('IP location fetch failed');
                const { lat, lon } = locData;

                const weatherRes = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`);
                if (!weatherRes.ok) throw new Error('Failed to fetch weather');
                const weatherData = await weatherRes.json();

                if (!weatherData.current_weather) return 'Can\'t fetch weather. :(';

                return "Weather: " + describeWeatherCode(weatherData.current_weather.weathercode);

            } catch (err) {
                console.error(err);
                return null;
            }
        }

        async function showWeather() {
            const weatherText = await getWeather();
            display.innerHTML = weatherText || "Can't get weather :(";
        }

        function replaceImageLinks(str) {
            return str.replace(
                /_image=(https?:\/\/[^\s]+\.(?:png|jpe?g|webp|gif|bmp|svg))_/gi,
                '<img src="$1" />'
            );
        }

        async function replaceAudioLinks(str) {
            let match = str.match(/_audio=(https?:\/\/[^\s]+\.(?:mp3|wav|ogg|m4a|aac))_/i);
            if (match) delay = await getAudioDuration(match[0].slice(7, -1));
            else delay = 3000;
            return str.replace(
                /_audio=(https?:\/\/[^\s]+\.(?:mp3|wav|ogg|m4a|aac))_/gi,
                (_, url) => `<audio src="${url}" autoplay loop></audio>`
            );
        }

        async function parseStr(input) {
            let output = replaceImageLinks(input);
            output = await replaceAudioLinks(output);
            return output;
        }

        async function getAudioDuration(url) {
            return new Promise((resolve, reject) => {
                const audio = new Audio();
                audio.crossOrigin = 'anonymous';
                audio.src = url;
                audio.addEventListener('loadedmetadata', () => {
                    resolve(audio.duration * 1000);
                });
                audio.addEventListener('error', (e) => {
                    reject(e);
                });
            });
        }

        let data = null;
        let channel = "1000";
        let prevChannel = null;
        let delay = 3000;
        let pendingFetch = false;

        async function fetchChannelData(chan) {
            if (pendingFetch) return; // prevent multiple simultaneous fetches
            pendingFetch = true;
            try {
                const res = await fetch(`channel-${chan}.json`);
                if (!res.ok) throw new Error('Failed to fetch channel data');
                data = await res.json();
                prevChannel = chan;
            } catch (err) {
                data = null;
                console.error(err);
            } finally {
                pendingFetch = false;
            }
        }

        async function setChannel() {
            const newChannel = channelInput.value.trim();
            if (newChannel && newChannel !== channel) {
                channel = newChannel;
                await fetchChannelData(channel);
                updateDisplayOnce();
            }
        }

        async function updateDisplayOnce() {
            if (!Array.isArray(data)) {
                display.textContent = createGibberish(50);
            } else {
                const now = Date.now();
                const idx = Math.floor(now / delay);
                const currentStr = data[idx % data.length];
                switch (currentStr) {
                    case "__weather__":
                        await showWeather();
                        break;
                    default:
                        display.innerHTML = await parseStr(currentStr);
                }
            }
        }

        async function tick() {
            if (pendingFetch) {
                display.textContent = createGibberish(50);
                setTimeout(tick, 20); // very fast retry if fetching
                return;
            }

            // If channel changed but fetch didnâ€™t happen yet, fetch it (fallback)
            if (prevChannel !== channel) {
                await fetchChannelData(channel);
            }

            // Show current message
            await updateDisplayOnce();

            setTimeout(tick, delay);
        }

        async function writeChannelMenu() {
            const select = document.getElementById('channelSelect');
            try {
                const res = await fetch('channels.json');
                if (!res.ok) throw new Error('Failed to fetch channels.json');
                const channels = await res.json();

                // Clear existing options
                select.innerHTML = '';

                // Add a default empty option
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '-- Select a channel --';
                select.appendChild(defaultOption);

                // Add channels to dropdown
                channels.forEach(ch => {
                    const option = document.createElement('option');
                    option.value = ch.id;
                    option.textContent = ch.name;
                    select.appendChild(option);
                });
            } catch (err) {
                console.error(err);
                select.innerHTML = '<option value="">Failed to load channels</option>';
            }
        }

        writeChannelMenu();

        tick();
    </script>
</body>
</html>